#' Generate time bins
#'
#' A function to generate time bins for a given study interval and geological
#' timescale. This function is flexible in that either stage-level or higher
#' stratigraphic-level (e.g. period) time bins can be called, valid timescales
#' from [Macrostrat](https://macrostrat.org/api/defs/timescales?all) can be
#' used, or a `data.frame` of a geological timescale can be provided. In
#' addition, near equal-length time bins can be generated by grouping
#' intervals together. For example, for a target bin size of 10 Myr, the
#' function will generate bins that have a mean bin length close to
#' 10 Myr. Similarly, for a given bin number n, the function will generate n
#' bins with a bin duration as equal as possible. However, users may also want
#' to consider grouping stages based on other reasoning e.g. availability of
#' outcrop (see Dean et al. 2020).
#'
#' @param interval \code{character or numeric}. Interval name available in
#'   \code{\link{GTS2020}} or \code{\link{GTS2012}}. If a single interval name
#'   is provided, this interval is returned. If two interval names are
#'   provided, these intervals and those existing between are returned. If a
#'   single numeric age is provided, the interval that covers this age is
#'   returned. If two numeric ages are provided, the intervals occurring in
#'   the range of these ages are returned. Defaults to "Phanerozoic". This
#'   argument is ignored if `scale` is not "GTS2020" or "GTS2012".
#' @param rank \code{character}. Which stratigraphic rank is desired? Choose
#'   from: "stage", "epoch", "period", "era", and "eon". This argument is
#'   ignored if `scale` is not "GTS2020" or "GTS2012".
#' @param size \code{numeric}. If equal-length time bins are desired, specify
#'   the length in millions of years (Myr) of the time bins desired.
#' @param n_bins \code{numeric}. For equal-length time bins, a fixed number of
#'   time bins can be specified instead of a bin `size`. Will be ignored if
#'   `size` is specified.
#' @param assign \code{numeric}. A numeric vector of age estimates to use to
#'   assign to requested bins. If assign is specified, a numeric vector is
#'   returned of the midpoint age of the specified bins. Note this is the
#'   simplified approach of assignment in `palaeoverse` included for data with
#'   'known' point-age estimates. For a wider range of binning methods, see
#'   \code{\link[palaeoverse:bin_time]{palaeoverse::bin_time()}}.
#' @param scale \code{character} or \code{data.frame}. Specify the desired
#'   geological timescale to be used: "GTS2020" (default), "GTS2012", a valid
#'   timescale from
#'   [Macrostrat](https://macrostrat.org/api/defs/timescales?all), or
#'   user-input `data.frame`. If a `data.frame` is provided, it must contain
#'   at least the following named columns: "interval_name", "max_ma", and
#'   "min_ma". As such, age data should be provided in Ma.
#' @param plot \code{logical}. Should a plot of time bins be generated?
#' @importFrom graphics polygon title
#' @importFrom stats sd
#' @importFrom curl nslookup
#' @importFrom grDevices col2rgb
#' @importFrom utils read.csv
#'
#' @return A \code{data.frame} of time bins for the specified intervals or a
#'   list with a \code{data.frame} of time bins and a named \code{numeric}
#'   vector (bin number) of binned age estimates (midpoint of specified bins)
#'   if `assign` is specified. By default, the time bins \code{data.frame}
#'   contains the following columns: bin, interval_name, rank, max_ma, mid_ma,
#'   min_ma, duration_myr, abbr (interval abbreviation), colour and font
#'   (colour). If `size` or `n` is specified, the time bins \code{data.frame}
#'   contains the following columns: bin, max_ma, mid_ma, min_ma,
#'   duration_myr, grouping_rank, intervals, colour and font.
#'
#' @details This function uses either the Geological Time Scale 2020,
#'   Geological Time Scale 2012, a valid timescale from
#'   [Macrostrat](https://macrostrat.org/api/defs/timescales?all), or a
#'   user-input `data.frame` (see `scale` argument) to generate time bins.
#'   Additional information on included Geological Time Scales and source can
#'   be accessed via:
#'   - \code{\link{GTS2020}}
#'   - \code{\link{GTS2012}}
#'
#'   Available interval names are accessible via the `interval_name` column
#'   in `GTS2012` and `GTS2020`. Data of the Geological Timescale 2020 and
#'   2012 were compiled by Lewis A. Jones (2022-07-02).
#'
#' @section References:
#' Dean, C.D., Chiarenza, A.A. and Maidment, S.C., 2020. Formation binning: a
#' new method for increased temporal resolution in regional studies, applied
#' to the Late Cretaceous dinosaur fossil record of North America.
#' Palaeontology, 63(6), 881-901. \doi{10.1111/pala.12492}.
#'
#' @section Developer(s):
#' Lewis A. Jones
#' @section Reviewer(s):
#' Kilian Eichenseer & William Gearty
#' @export
#' @examples
#' #Using numeric age
#' ex1 <- time_bins(interval = 10, plot = TRUE)
#'
#' #Using numeric age range
#' ex2 <- time_bins(interval = c(50, 100), plot = TRUE)
#'
#' #Using a single interval name
#' ex3 <- time_bins(interval = c("Maastrichtian"), plot = TRUE)
#'
#' #Using a range of intervals and near-equal duration bins
#' ex4 <- time_bins(interval = c("Fortunian", "Meghalayan"),
#'                  size = 10, plot = TRUE)
#'
#' #Assign bins based on given age estimates
#' ex5 <- time_bins(interval = c("Fortunian", "Meghalayan"),
#'                  assign = c(232, 167, 33))
#'
#' #Use user-input data.frame to generate near-equal length bins
#' scale <- data.frame(interval_name = 1:5,
#'                     min_ma = c(0, 18, 32, 38, 45),
#'                     max_ma = c(18, 32, 38, 45, 53))
#' ex6 <- time_bins(scale = scale, size = 20, plot = TRUE)
#'
#' #Use North American land mammal ages from Macrostrat and specify a desired
#' #number of bins
#' ex7 <- time_bins(scale = "North American land mammal ages", n = 7)
#'
time_bins <- function(interval = "Phanerozoic", rank = "stage", size = NULL,
                      n_bins = NULL, assign = NULL, scale = "GTS2020",
                      plot = FALSE) {
  # Error handling -------------------------------------------------------
  if (!is.character(interval) &&
      !is.numeric(interval) &&
      !is.null(interval)) {
    stop("`interval` must be NULL or of class 'character' or 'numeric'")
  }

  if (!is.numeric(size) && !is.null(size)) {
    stop("`size` should be a 'numeric' or NULL.")
  }

  if (!is.numeric(n_bins) && !is.null(n_bins)) {
    stop("`size` should be a 'numeric' or NULL.")
  }

  if (!is.logical(plot)) {
    stop("`plot` should be logical (TRUE/FALSE).")
  }

  if (is.numeric(assign) && any(assign < 0)) {
    stop(paste("Age estimates for `assign` should be non-negative values.",
               "Hint: You can transform your data using abs()."))
  }

  if (!is.character(scale) && !is.data.frame(scale)) {
    stop(paste("`scale` must be either:\n",
               "The name of an in-built time scale (e.g. 'GTS2020'),",
               "the name of a Macrostrat time scale (see details),",
               "or a `data.frame`."))
  }

  if (is.data.frame(scale) &&
      any(!c("interval_name", "max_ma", "min_ma") %in% colnames(scale))) {
    stop(paste("`scale` does not contain named columns:",
               "'interval_name', 'max_ma', and 'min_ma'."))
  }

  if (length(interval) > 2 && !is.null(interval)) {
    stop(paste("`interval` must be a 'character' or",
               "'numeric' vector of length 1 or 2",
               "or NULL."))
  }

  if (length(rank) > 1) {
    stop("`rank` must be of length 1.")
  }

  if (!rank %in% c("stage", "epoch", "period", "era", "eon", NULL)) {
    stop("`rank` must be either: stage, epoch, period, era, eon, or NULL.")
  }

  # Input dataframe scale ------------------------------------------------
  if (is.data.frame(scale)) {
    # Assign input scale to df
    df <- scale
    # Update scale/rank
    scale <- "user"
    rank <- "user"
    # Add mid_ma
    df$mid_ma <- (df$max_ma + df$min_ma) / 2
    # Add duration
    df$duration_myr <- (df$max_ma - df$min_ma)
    # Add bin number
    df$bin <- seq_len(nrow(df))
    # Add scale as rank
    df$rank <- scale
    # Add colour column if it doesn't already exist
    if (!"colour" %in% colnames(df)) {
      df$colour <- "#80cdc1"
    }
    # Add abbr column if it doesn't already exist
    if (!"abbr" %in% colnames(df)) {
      df$abbr <- NA
    }
  }
  # In-built scales ------------------------------------------------------
  if (scale %in% c("GTS2020", "GTS2012")) {
    if (is.null(interval)) {
      stop("`interval` is NULL. You must define an interval/age range.")
    }
    # Which geological timescale to use?
    if (scale == "GTS2020") {
      df <- palaeoverse::GTS2020
    } else if (scale == "GTS2012") {
      df <- palaeoverse::GTS2012
    }
    # Update interval number to bin number
    colnames(df)[which(colnames(df) == "interval_number")] <- "bin"
    # Filter dataset by desired interval names (character string)
    if (is.character(interval)) {
      # Check interval names
      int_index <- charmatch(interval, df$interval_name)
      if (any(is.na(int_index))) {
        stop(paste("Check spelling of specified intervals.",
                   "Available intervals are accessible via GTS2020 and GTS2012."))
      }
      # Subset df for intervals
      if (length(int_index) > 1) {
        int_min <- min(c(df$min_ma[int_index[1]], df$min_ma[int_index[2]]))
        int_max <- max(c(df$max_ma[int_index[1]], df$max_ma[int_index[2]]))
        int_index <- c(int_min, int_max)
      } else {
        int_index <- c(df$min_ma[int_index], df$max_ma[int_index])
      }
      # Subset df
      int_index <- which(df$max_ma > min(int_index) &
                           df$min_ma < max(int_index))
    }
    # Filter dataset by desired interval ages (numeric string)
    if (is.numeric(interval)) {
      # Check age range
      if (max(interval) > max(df$max_ma)) {
        stop("maximum `interval` value is greater than available intervals")
      }
      if (min(interval) < min(df$min_ma)) {
        stop("minimum `interval` value is less than available intervals")
      }
      # Subset df
      int_index <- which(df$max_ma >= min(interval) &
                           df$min_ma <= max(interval))
    }
    # Sort int_index
    int_index <- sort(int_index)
    # Subset df for intervals
    df <- df[int_index, ]
    # Which rank should be used?
    df <- df[which(df$rank == rank), ]
    # Error handle
    if (nrow(df) == 0) {
      stop("No intervals are available for the defined interval range.")
    }
  }
  # Macrostrat dataframe scale -------------------------------------------
  if (!scale %in% c("GTS2020", "GTS2012", "user")) {
    # Assign scale to rank
    rank <- scale
    # Try to get the time scale from Macrostrat
    # Online and Macrostrat available?
    tryCatch(
      {
        nslookup("macrostrat.org")
      },
      error = function(e) {
        stop("Macrostrat is not available. Either the site is down or you are
             not connected to the internet.",
             call. = FALSE
        )
      }
    )
    url <- url(paste0("https://macrostrat.org/api/v2/defs/intervals",
                      "?format=csv&timescale=",
                      gsub(" ", "%20", scale)))
    df <- tryCatch(
      {
        read.csv(url, header = TRUE, stringsAsFactors = FALSE)
      },
      error = function(e) {
        stop("`name` does not match a built-in or Macrostrat time scale.",
             call. = FALSE)
      })
    df <- df[, c("name", "b_age", "t_age", "abbrev", "color")]
    colnames(df) <- c("interval_name", "max_ma", "min_ma", "abbr", "colour")
    # Add mid_ma
    df$mid_ma <- (df$max_ma + df$min_ma) / 2
    # Add duration
    df$duration_myr <- (df$max_ma - df$min_ma)
    # Add bin number
    df$bin <- seq_len(nrow(df))
    # Add scale as rank
    df$rank <- scale
  }
  # Add font colour if it doesn't exist
  if (!("font" %in% colnames(df))) {
    # Font colours based on luminance as per
    # https://stackoverflow.com/a/1855903/4660582
    rgbs <- col2rgb(df$colour)
    luminance <- apply(rgbs, 2, function(x) {
      (0.299 * x[1] + 0.587 * x[2] + 0.114 * x[3]) / 255
    })
    df$font <- ifelse(luminance > .5, "black", "white")
  }
  # Tidy dataframe -------------------------------------------------------
  # Abbreviate names if required
  if (any(is.na(df$abbr))) {
    df$abbr <- abbreviate(df$interval_name, minlength = 1,
                          use.classes = FALSE, named = FALSE)
  }
  # Reorder dataframe
  df <- df[, c("bin", "interval_name", "rank", "max_ma", "mid_ma",
               "min_ma", "duration_myr", "abbr", "colour", "font")]
  df <- df[order(-df$max_ma), ]
  # Generate equal-length bins? ------------------------------------------
  if (is.numeric(size) || is.numeric(n_bins)) {
    # Update bin size for age range
    total_duration <- max(df$max_ma) - min(df$min_ma)
    # How many bins should be generated?
    if (is.numeric(size)) {
      n_bins <- round(total_duration / size)
      # Set n_bins to interval number if size results in too large n_bins
      if (n_bins > nrow(df)) {
          n_bins <- nrow(df)
        }
    } else {
      # Throw error if n_bins is too large
      if (n_bins > nrow(df)) {
        stop("`n_bins` can't be greater than the number intervals.")
      }
    }
    if (n_bins > 1) {
    # updated bin size based on determined number of bins
    target_bin_size <- total_duration / n_bins
    # Extract interval durations and number of intervals
    interval_durations <- df$duration_myr
    n_intervals <- length(interval_durations)
    # Calculate cumulative durations (leading zero for easier indexing)
    cumulative_durations <- c(0, cumsum(interval_durations))
    #
    # Initialise dynamic programming table and partition table
    # M[i, k]: Min total cost for first i intervals partitioned into k bins
    M <- matrix(Inf, nrow = n_intervals + 1, ncol = n_bins)
    partition <- matrix(NA, nrow = n_intervals + 1, ncol = n_bins)
    # Base case: Cost of partitioning 0 intervals into 0 bins is 0
    M[1, 1] <- 0
    # Initialise base cases for k = 1 (partitioning into one bin)
    for (i in 1:n_intervals) {
      bin_duration <- cumulative_durations[i + 1] - cumulative_durations[1]
      M[i + 1, 1] <- (bin_duration - target_bin_size)^2
      partition[i + 1, 1] <- 0
    }
    #
    # Fill the dynamic programming table
    for (k in 2:n_bins) {  # Bins from 2 to n_bins
      for (i in k:n_intervals) {  # Intervals from k to n_intervals
        for (j in (k - 1):(i - 1)) {  # Possible partition points
          bin_duration <- cumulative_durations[i + 1] - cumulative_durations[j + 1]
          cost <- M[j + 1, k - 1] + (bin_duration - target_bin_size)^2
          if (cost < M[i + 1, k]) {
            M[i + 1, k] <- cost
            partition[i + 1, k] <- j
          }
        }
      }
    }
    #
    # Backtracking to find the optimal partitioning
    bins <- vector("list", n_bins) # empty list for bins
    i <- n_intervals
    k <- n_bins
    while (k > 0) {
      j <- partition[i + 1, k]
      bins[[k]] <- (j + 1):i
      i <- j
      k <- k - 1
    }
    } else {
      # if only 1 bin
      bins <- list(seq_len(nrow(df)))
    }
    #
    # Assemble bins and compute bin statistics
    # Initialise an empty list to store the rows for bin_data
    binDataList <- vector("list", length(bins))
    # Iterate over bins
    for (i in seq_along(bins)) {
      binIntervals <- bins[[i]]
      binMaxMa <- max(df[binIntervals, "max_ma"])
      binMinMa <- min(df[binIntervals, "min_ma"])
      # Collect data for each bin in a list
      binDataList[[i]] <- data.frame(
        bin = as.integer(i),
        max_ma = as.numeric(binMaxMa),
        mid_ma = as.numeric((binMinMa + binMaxMa) / 2),
        min_ma = as.numeric(binMinMa),
        duration_myr = as.numeric(sum(df[binIntervals, "duration_myr"])),
        grouping_rank = rank,
        intervals = toString(df[binIntervals, "interval_name"]),
        stringsAsFactors = FALSE
      )
    }
    # List to dataframe
    df <- do.call(rbind, binDataList)
    #
    # Calculate mean and standard deviation of bin durations
    mean_duration <- mean(df$duration_myr)
    sd_duration <- sd(df$duration_myr)
    #
    # Message user
    if (is.numeric(size)) {
      message_head <- paste("Target duration of equal length time bins was set to",
                            round(size, digits = 2),  "Myr.\n")
    } else {
      message_head <- paste("Number of equal length time bins was set to",
                            n_bins, ".\n")
    }
    message(
      paste(message_head,
            n_bins,
            "time bins were generated with a mean length of",
            round(mean_duration, digits = 2),
            "Myr and a standard deviation of",
            round(sd_duration, digits = 2),
            "Myr."
      )
    )
  }
  # Plot data? -----------------------------------------------------------
  if (plot) {
    if (is.numeric(size) || is.numeric(n_bins)) {
      df$colour <- c("#80cdc1")
      df$font <- c("black")
    }
    plot(1, type = "n",
         xlim = c(max(df$max_ma), min(df$min_ma)),
         ylim = c(0, max(df$duration_myr)),
         xlab = "Time (Ma)",
         ylab = "Duration (Myr)"
    )
    for (i in seq_len(length.out = nrow(df))) {
      polygon(
        x = c(df$min_ma[i], df$max_ma[i], df$max_ma[i], df$min_ma[i]),
        y = c(0, 0, df$duration_myr[i], df$duration_myr[i]),
        col = df$colour[i]
      )
    }
    if (is.numeric(size) || is.numeric(n_bins)) {
      title(paste(
        "Mean bin length =",
        round(mean_duration, digits = 2),
        "(standard deviation =",
        round(sd_duration, digits = 2),
        ")"
      ))
    }
  }
  # Assign data? ---------------------------------------------------------
  if (!is.null(assign)) {
    if (is.numeric(assign)) {
      if (any(assign > max(df$max_ma) | assign < min(df$min_ma))) {
        stop("One or more ages is outside the specified time interval range")
      }
      tmp <- assign
      for (i in seq_len(length.out = nrow(df))) {
        assign[which(tmp <= df$max_ma[i] &
                       tmp >= df$min_ma[i])] <- df$mid_ma[i]
        names(assign)[which(tmp <= df$max_ma[i] &
                              tmp >= df$min_ma[i])] <- df$bin[i]
      }
      assign <- list(df, assign)
      names(assign) <- c("Bins", "Assignation")
      return(assign)
    } else {
      stop("`assign` should be a numeric")
    }
  }
  # Clean up --------------------------------------------------------------
  # Ensure consistency
  df <- df[order(df$mid_ma, decreasing = TRUE), ]
  df$bin <- seq_len(nrow(df))
  row.names(df) <- NULL
  return(df)
}
