#' Generate time bins
#'
#' A function to generate time bins for a given study interval and geological
#' timescale. This function is flexible in that either stage-level or higher
#' stratigraphic-level (e.g. period) time bins can be called, valid timescales
#' from [Macrostrat](https://macrostrat.org/api/defs/timescales?all) can be
#' used, or a `data.frame` of a geological timescale can be provided. In
#' addition, near equal-length time bins can be generated by grouping
#' intervals together. For example, for a target bin size of 10 Myr, the
#' function will generate bins that have a mean bin length close to
#' 10 Myr. Similarly, for a specified number of bins (`n_bins`), the function
#' will generate this number of bins with with a bin duration as uniform as
#' possible. However, users may also want to consider grouping stages based on
#' other reasoning e.g. availability of outcrop (see Dean et al. 2020).
#'
#' @param interval \code{character or numeric}. Interval name available in
#'   \code{\link{GTS2020}} or \code{\link{GTS2012}}. If a single interval name
#'   is provided, this interval is returned. If two interval names are
#'   provided, these intervals and those existing between are returned. If a
#'   single numeric age is provided, the interval that covers this age is
#'   returned. If two numeric ages are provided, the intervals occurring in
#'   the range of these ages are returned. Defaults to "Phanerozoic". This
#'   argument is ignored if `scale` is not "GTS2020" or "GTS2012".
#' @param rank \code{character}. Which stratigraphic rank is desired? Choose
#'   from: "stage", "epoch", "period", "era", and "eon". This argument is
#'   ignored if `scale` is not "GTS2020" or "GTS2012".
#' @param size \code{numeric}. If equal-length time bins are desired, specify
#'   the length in millions of years (Myr) of the time bins desired.
#' @param n_bins \code{numeric}. For equal-length time bins, a fixed number of
#'   time bins can be specified instead of a bin `size`. This argument will be
#'   ignored if `size` is specified.
#' @param assign \code{numeric}. A numeric vector of age estimates to use to
#'   assign to requested bins. If assign is specified, a numeric vector is
#'   returned of the midpoint age of the specified bins. Note this is the
#'   simplified approach of assignment in `palaeoverse` included for data with
#'   'known' point-age estimates. For a wider range of binning methods, see
#'   \code{\link[palaeoverse:bin_time]{palaeoverse::bin_time()}}.
#' @param scale \code{character} or \code{data.frame}. Specify the desired
#'   geological timescale to be used: "GTS2020" (default), "GTS2012", a valid
#'   timescale from
#'   [Macrostrat](https://macrostrat.org/api/defs/timescales?all), or
#'   user-input `data.frame`. If a `data.frame` is provided, it must contain
#'   at least the following named columns: "interval_name", "max_ma", and
#'   "min_ma". As such, age data should be provided in Ma.
#' @param plot \code{logical}. Should a plot of time bins be generated?
#' @importFrom graphics polygon title
#' @importFrom stats sd
#' @importFrom curl nslookup
#' @importFrom grDevices col2rgb
#' @importFrom utils read.csv
#'
#' @return A \code{data.frame} of time bins for the specified intervals or a
#'   list with a \code{data.frame} of time bins and a named \code{numeric}
#'   vector (bin number) of binned age estimates (midpoint of specified bins)
#'   if `assign` is specified. By default, the time bins \code{data.frame}
#'   contains the following columns: bin, interval_name, rank, max_ma, mid_ma,
#'   min_ma, duration_myr, abbr (interval abbreviation), colour and font
#'   (colour). If `size` or `n_bins` is specified, the time bins
#'   \code{data.frame} contains the following columns: bin, max_ma, mid_ma,
#'   min_ma, duration_myr, grouping_rank, intervals, colour and font.
#'
#' @details This function uses either the Geological Time Scale 2020,
#'   Geological Time Scale 2012, a valid timescale from
#'   [Macrostrat](https://macrostrat.org/api/defs/timescales?all), or a
#'   user-input `data.frame` (see `scale` argument) to generate time bins.
#'   Note, timescales from
#'   [Macrostrat](https://macrostrat.org/api/defs/timescales?all) tend to
#'   contain the most up-to-date information (e.g. the Geological Time Scale).
#'   Additional information on included Geological Time Scales and source can
#'   be accessed via:
#'   - \code{\link{GTS2020}}
#'   - \code{\link{GTS2012}}
#'
#'   Available interval names are accessible via the `interval_name` column
#'   in `GTS2012` and `GTS2020`. Data of the Geological Timescale 2020 and
#'   2012 were compiled by Lewis A. Jones (2022-07-02).
#'
#' @section References:
#' Dean, C.D., Chiarenza, A.A. and Maidment, S.C., 2020. Formation binning: a
#' new method for increased temporal resolution in regional studies, applied
#' to the Late Cretaceous dinosaur fossil record of North America.
#' Palaeontology, 63(6), 881-901. \doi{10.1111/pala.12492}.
#'
#' @section Developer(s):
#' Lewis A. Jones & Kilian Eichenseer
#' @section Reviewer(s):
#' Kilian Eichenseer & William Gearty
#' @export
#' @examples
#' #Using numeric age
#' ex1 <- time_bins(interval = 10, plot = TRUE)
#'
#' #Using numeric age range
#' ex2 <- time_bins(interval = c(50, 100), plot = TRUE)
#'
#' #Using a single interval name
#' ex3 <- time_bins(interval = c("Maastrichtian"), plot = TRUE)
#'
#' #Using a range of intervals and near-equal duration bins
#' ex4 <- time_bins(interval = c("Fortunian", "Meghalayan"),
#'                  size = 10, plot = TRUE)
#'
#' #Assign bins based on given age estimates
#' ex5 <- time_bins(interval = c("Fortunian", "Meghalayan"),
#'                  assign = c(232, 167, 33))
#'
#' #Use user-input data.frame to generate near-equal length bins
#' scale <- data.frame(interval_name = 1:5,
#'                     min_ma = c(0, 18, 32, 38, 45),
#'                     max_ma = c(18, 32, 38, 45, 53))
#' ex6 <- time_bins(scale = scale, size = 20, plot = TRUE)
#'
#' #Use North American land mammal ages from Macrostrat and specify a desired
#' #number of bins
#' ex7 <- time_bins(scale = "North American land mammal ages", n_bins = 7)
#'
time_bins <- function(interval = "Phanerozoic", rank = "stage", size = NULL,
                      n_bins = NULL, assign = NULL, scale = "GTS2020",
                      plot = FALSE) {
  # Error handling -------------------------------------------------------
  if (!is.character(interval) &&
      !is.numeric(interval) &&
      !is.null(interval)) {
    stop("`interval` must be NULL or of class 'character' or 'numeric'")
  }

  if (!is.numeric(size) && !is.null(size)) {
    stop("`size` should be a 'numeric' or NULL.")
  }

  if (!is.numeric(n_bins) && !is.null(n_bins)) {
    stop("`size` should be a 'numeric' or NULL.")
  }

  if (!is.logical(plot)) {
    stop("`plot` should be logical (TRUE/FALSE).")
  }

  if (is.numeric(assign) && any(assign < 0)) {
    stop(paste("Age estimates for `assign` should be non-negative values.",
               "Hint: You can transform your data using abs()."))
  }

  if (!is.character(scale) && !is.data.frame(scale)) {
    stop(paste("`scale` must be either:\n",
               "The name of an in-built time scale (e.g. 'GTS2020'),",
               "the name of a Macrostrat time scale (see details),",
               "or a `data.frame`."))
  }

  if (is.data.frame(scale) &&
      any(!c("interval_name", "max_ma", "min_ma") %in% colnames(scale))) {
    stop(paste("`scale` does not contain named columns:",
               "'interval_name', 'max_ma', and 'min_ma'."))
  }

  if (length(interval) > 2 && !is.null(interval)) {
    stop(paste("`interval` must be a 'character' or",
               "'numeric' vector of length 1 or 2",
               "or NULL."))
  }

  if (length(rank) > 1) {
    stop("`rank` must be of length 1.")
  }

  if (!rank %in% c("stage", "epoch", "period", "era", "eon", NULL)) {
    stop("`rank` must be either: stage, epoch, period, era, eon, or NULL.")
  }

  # Input dataframe scale ------------------------------------------------
  if (is.data.frame(scale)) {
    # Assign input scale to df
    df <- scale
    # Update scale/rank
    scale <- "user"
    rank <- "user"
    # Add mid_ma
    df$mid_ma <- (df$max_ma + df$min_ma) / 2
    # Add duration
    df$duration_myr <- (df$max_ma - df$min_ma)
    # Add bin number
    df$bin <- seq_len(nrow(df))
    # Add scale as rank
    df$rank <- scale
    # Add colour column if it doesn't already exist
    if (!"colour" %in% colnames(df)) {
      df$colour <- "#80cdc1"
    }
    # Add abbr column if it doesn't already exist
    if (!"abbr" %in% colnames(df)) {
      df$abbr <- NA
    }
  }
  # In-built scales ------------------------------------------------------
  if (scale %in% c("GTS2020", "GTS2012")) {
    if (is.null(interval)) {
      stop("`interval` is NULL. You must define an interval/age range.")
    }
    # Which geological timescale to use?
    if (scale == "GTS2020") {
      df <- palaeoverse::GTS2020
    } else if (scale == "GTS2012") {
      df <- palaeoverse::GTS2012
    }
    # Update interval number to bin number
    colnames(df)[which(colnames(df) == "interval_number")] <- "bin"
    # Filter dataset by desired interval names (character string)
    if (is.character(interval)) {
      # Check interval names
      int_index <- charmatch(interval, df$interval_name)
      if (any(is.na(int_index))) {
        stop(
          paste("Check spelling of specified intervals.",
                "Available intervals are accessible via GTS2020 and GTS2012."))
      }
      # Subset df for intervals
      if (length(int_index) > 1) {
        int_min <- min(c(df$min_ma[int_index[1]], df$min_ma[int_index[2]]))
        int_max <- max(c(df$max_ma[int_index[1]], df$max_ma[int_index[2]]))
        int_index <- c(int_min, int_max)
      } else {
        int_index <- c(df$min_ma[int_index], df$max_ma[int_index])
      }
      # Subset df
      int_index <- which(df$max_ma > min(int_index) &
                           df$min_ma < max(int_index))
    }
    # Filter dataset by desired interval ages (numeric string)
    if (is.numeric(interval)) {
      # Check age range
      if (max(interval) > max(df$max_ma)) {
        stop("maximum `interval` value is greater than available intervals")
      }
      if (min(interval) < min(df$min_ma)) {
        stop("minimum `interval` value is less than available intervals")
      }
      # Subset df
      int_index <- which(df$max_ma >= min(interval) &
                           df$min_ma <= max(interval))
    }
    # Sort int_index
    int_index <- sort(int_index)
    # Subset df for intervals
    df <- df[int_index, ]
    # Which rank should be used?
    df <- df[which(df$rank == rank), ]
    # Error handle
    if (nrow(df) == 0) {
      stop("No intervals are available for the defined interval range.")
    }
  }
  # Macrostrat dataframe scale -------------------------------------------
  if (!scale %in% c("GTS2020", "GTS2012", "user")) {
    # Assign scale to rank
    rank <- scale
    # Try to get the time scale from Macrostrat
    # Online and Macrostrat available?
    tryCatch(
      {
        nslookup("macrostrat.org")
      },
      error = function(e) {
        stop("Macrostrat is not available. Either the site is down or you are
             not connected to the internet.",
             call. = FALSE
        )
      }
    )
    url <- url(paste0("https://macrostrat.org/api/v2/defs/intervals",
                      "?format=csv&timescale=",
                      gsub(" ", "%20", scale)))
    df <- tryCatch({
      read.csv(url, header = TRUE, stringsAsFactors = FALSE)
    },
    error = function(e) {
      stop("`name` does not match a built-in or Macrostrat time scale.",
           call. = FALSE)
    })
    df <- df[, c("name", "b_age", "t_age", "abbrev", "color")]
    colnames(df) <- c("interval_name", "max_ma", "min_ma", "abbr", "colour")
    # Add mid_ma
    df$mid_ma <- (df$max_ma + df$min_ma) / 2
    # Add duration
    df$duration_myr <- (df$max_ma - df$min_ma)
    # Add bin number
    df$bin <- seq_len(nrow(df))
    # Add scale as rank
    df$rank <- scale
  }
  # Add font colour if it doesn't exist
  if (!("font" %in% colnames(df))) {
    # Font colours based on luminance as per
    # https://stackoverflow.com/a/1855903/4660582
    rgbs <- col2rgb(df$colour)
    luminance <- apply(rgbs, 2, function(x) {
      (0.299 * x[1] + 0.587 * x[2] + 0.114 * x[3]) / 255
    })
    df$font <- ifelse(luminance > .5, "black", "white")
  }
  # Tidy dataframe -------------------------------------------------------
  # Abbreviate names if required
  if (any(is.na(df$abbr))) {
    df$abbr <- abbreviate(df$interval_name, minlength = 1,
                          use.classes = FALSE, named = FALSE)
  }
  # Reorder dataframe
  df <- df[, c("bin", "interval_name", "rank", "max_ma", "mid_ma",
               "min_ma", "duration_myr", "abbr", "colour", "font")]
  df <- df[order(-df$max_ma), ]
  # Generate equal-length bins? ------------------------------------------
  if (is.numeric(size) || is.numeric(n_bins)) {
    # Update bin size for age range
    total_duration <- max(df$max_ma) - min(df$min_ma)
    # How many bins should be generated?
    if (is.numeric(size)) {
      n_bins <- round(total_duration / size)
      # Set n_bins to interval number if size results in too large n_bins
      if (n_bins > nrow(df)) {
        n_bins <- nrow(df)
      }
    } else {
      # Throw error if n_bins is too large
      if (n_bins > nrow(df)) {
        stop("`n_bins` can't be greater than the number of intervals.")
      }
    }
    if (n_bins > 1) {
      # updated bin size based on determined number of bins
      target_bin_size <- total_duration / n_bins
      # Extract interval durations and number of intervals
      interval_durations <- df$duration_myr
      n_intervals <- length(interval_durations)
      # Calculate cumulative durations (leading zero for easier indexing)
      cumulative_durations <- c(0, cumsum(interval_durations))
      #
      # Initialise dynamic programming table and partition table
      # cost_mat[i, k]: Min total cost for first i intervals partitioned into k
      # bins
      cost_mat <- matrix(Inf, nrow = n_intervals + 1, ncol = n_bins)
      partition <- matrix(NA, nrow = n_intervals + 1, ncol = n_bins)
      # Base case: Cost of partitioning 0 intervals into 0 bins is 0
      cost_mat[1, 1] <- 0
      # Initialise base cases for k = 1 (partitioning into one bin)
      for (i in 1:n_intervals) {
        bin_duration <- cumulative_durations[i + 1] - cumulative_durations[1]
        cost_mat[i + 1, 1] <- (bin_duration - target_bin_size)^2
        partition[i + 1, 1] <- 0
      }
      #
      # Fill the dynamic programming table
      for (k in 2:n_bins) {  # Bins from 2 to n_bins
        for (i in k:n_intervals) {  # Intervals from k to n_intervals
          for (j in (k - 1):(i - 1)) {  # Possible partition points
            bin_duration <-
              cumulative_durations[i + 1] - cumulative_durations[j + 1]
            cost <- cost_mat[j + 1, k - 1] + (bin_duration - target_bin_size)^2
            if (cost < cost_mat[i + 1, k]) {
              cost_mat[i + 1, k] <- cost
              partition[i + 1, k] <- j
            }
          }
        }
      }
      #
      # Backtracking to find the optimal partitioning
      bins <- vector("list", n_bins) # empty list for bins
      i <- n_intervals
      k <- n_bins
      while (k > 0) {
        j <- partition[i + 1, k]
        bins[[k]] <- (j + 1):i
        i <- j
        k <- k - 1
      }
    } else {
      # if only 1 bin
      bins <- list(seq_len(nrow(df)))
    }
    #
    # Assemble bins and compute bin statistics
    # Initialise an empty list to store the rows for bin_data
    bin_data_list <- vector("list", length(bins))
    # Iterate over bins
    for (i in seq_along(bins)) {
      bin_intervals <- bins[[i]]
      bin_max_ma <- max(df[bin_intervals, "max_ma"])
      bin_min_ma <- min(df[bin_intervals, "min_ma"])
      # Collect data for each bin in a list
      bin_data_list[[i]] <- data.frame(
        bin = as.integer(i),
        max_ma = as.numeric(bin_max_ma),
        mid_ma = as.numeric((bin_min_ma + bin_max_ma) / 2),
        min_ma = as.numeric(bin_min_ma),
        duration_myr = as.numeric(sum(df[bin_intervals, "duration_myr"])),
        grouping_rank = rank,
        intervals = toString(df[bin_intervals, "interval_name"]),
        stringsAsFactors = FALSE
      )
    }
    # List to dataframe
    df <- do.call(rbind, bin_data_list)
    #
    # Calculate mean and standard deviation of bin durations
    mean_duration <- mean(df$duration_myr)
    sd_duration <- sd(df$duration_myr)
    #
    # Message user
    if (is.numeric(size)) {
      message_head <- paste(
        "Target duration of equal length time bins was set to",
        round(size, digits = 2),  "Myr.\n")
    } else {
      message_head <- paste0("Number of equal length time bins was set to ",
                             n_bins, ".\n")
    }
    message(
      paste0(message_head,
             n_bins,
             " time bins were generated with a mean length of ",
             round(mean_duration, digits = 2),
             " Myr and a standard deviation of ",
             round(sd_duration, digits = 2),
             " Myr."
      )
    )
  }
  # Plot data? -----------------------------------------------------------
  if (plot) {
    if (is.numeric(size) || is.numeric(n_bins)) {
      df$colour <- c("#80cdc1")
      df$font <- c("black")
    }
    plot(1, type = "n",
         xlim = c(max(df$max_ma), min(df$min_ma)),
         ylim = c(0, max(df$duration_myr)),
         xlab = "Time (Ma)",
         ylab = "Duration (Myr)"
    )
    for (i in seq_len(length.out = nrow(df))) {
      polygon(
        x = c(df$min_ma[i], df$max_ma[i], df$max_ma[i], df$min_ma[i]),
        y = c(0, 0, df$duration_myr[i], df$duration_myr[i]),
        col = df$colour[i]
      )
    }
    if (is.numeric(size) || is.numeric(n_bins)) {
      title(paste0(
        "Mean bin length = ",
        round(mean_duration, digits = 2),
        " (standard deviation = ",
        round(sd_duration, digits = 2),
        ")"
      ))
    }
  }
  # Assign data? ---------------------------------------------------------
  if (!is.null(assign)) {
    if (is.numeric(assign)) {
      if (any(assign > max(df$max_ma) | assign < min(df$min_ma))) {
        stop("One or more ages is outside the specified time interval range")
      }
      tmp <- assign
      for (i in seq_len(length.out = nrow(df))) {
        assign[which(tmp <= df$max_ma[i] &
                       tmp >= df$min_ma[i])] <- df$mid_ma[i]
        names(assign)[which(tmp <= df$max_ma[i] &
                              tmp >= df$min_ma[i])] <- df$bin[i]
      }
      assign <- list(df, assign)
      names(assign) <- c("Bins", "Assignation")
      return(assign)
    } else {
      stop("`assign` should be a numeric")
    }
  }
  # Clean up --------------------------------------------------------------
  # Ensure consistency
  df <- df[order(df$mid_ma, decreasing = TRUE), ]
  df$bin <- seq_len(nrow(df))
  row.names(df) <- NULL
  return(df)
}
